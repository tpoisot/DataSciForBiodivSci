# Supp. Mat. - Clustering

This notebook uses data from the USGS Landsat 9 products. They are *not* distributed with the notebook because they are pretty large. We work from the `.dat` files that have been extracted from the raw data instead.

```{julia}
_code_path = joinpath(@__DIR__, "..", "lib")
include(joinpath(_code_path, "pkg.jl"))
include(joinpath(_code_path, "colorcube.jl"))
include(joinpath(_code_path, "landsat.jl"))
include(joinpath(_code_path, "daviesbouldin.jl"))
```

Read the different datafiles

```{julia}
_data_path = joinpath(@__DIR__, "..", "data", "kmeans", "cooked")
R, G, B, N, S1, S2 = readlandsat(_data_path)
```

RGB composite

natural color 4,3,2
cir 5,4,3
false urban 7,6,4
false veg 6,5,4

```{julia}
#| label: fig-kmeans-composites
#| fig-cap: The Landsat 9 data are combined into the "Natural Color" image, in which the red, green, and blue bands are mapped to their respective channels (left). The two other composites are the false color infrared, and the composite for vegetation analysis. Note that the true-color composite is slightly distored compared to the colors of the landscape we expect; this is because natural colors are difficult to reproduce accurately.
rgb_cube = colorcube(R, G, B; natural=true)
veg_cube = colorcube(S1, N, R)
cir_cube = colorcube(N, R, G)

fig = Figure(resolution=(500, 150))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_cir = Makie.Axis(fig[1,3], aspect=DataAspect())

image!(ax_rgb, load(assetpath(rgb_cube)))
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_cir, load(assetpath(cir_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_cir)

current_figure()
```

Now we can do the NDVI, NDMI, NDWI

```{julia}
ndvi = @. (N - R) / (N + R)
ndwi = @. (G - N) / (G + N)
ndmi = @. (N - S1) / (N + S1)
nbr = @. (N - S2) / (N + S2)
```

and combine in a single matrix

```{julia}
X = zeros(Float32, (4, prod(size(ndvi))...))
X[1,:] .= vec(ndvi)
X[2,:] .= vec(ndwi)
X[3,:] .= vec(ndmi)
X[4,:] .= vec(nbr)
size(X)
```

plot

```{julia}
#| label: fig-kmeans-hexbin
#| fig-cap: The pixels acquired from Landsat 8 exist in a space with many different dimensions (one for each band). Because we are interested in a landscape classification based on water and vegetation data, we use the NDVI, NDMI, NDWI, and NBR combinations of bands. These are *derived* data, and represent the creation of new features from the raw data. Darker colors indicate more pixels in this bin.
fig = Figure(resolution=(500,300))
ax = Makie.Axis(fig[1,1]; xlabel="Vegetation", ylabel="Moisture")
hexbin!(ax, vec(ndvi), vec(ndmi), colormap=[:lightgrey, :black], bins=120)
tightlimits!(ax)
current_figure()
```

initial split

```{julia}
using Clustering
clusters = kmeans(X, 3)
```

initial classification

```{julia}
#| label: fig-kmeans-initial-landscape
#| fig-cap: After iterating the *k*-means algorithm, we obtain a classification for every pixel in the landscape. This classification is based on the values of NDVI, NDMI, NBR, and NDWI indices, and therefore groups pixels based on specific assumptions about vegetation and stress. This clustering was produced using $k=3$, *i.e.* we want to see what the landscape would look like when divided into three categories. 

C = permutedims(reshape(assignments(clusters), size(ndvi)))

fig = Figure(resolution=(500, 150))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_cir = Makie.Axis(fig[1,3], aspect=DataAspect())

heatmap!(ax_rgb, C; colormap=:Dark2_3)
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_cir, load(assetpath(cir_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_cir)

current_figure()
```

cluster score

```{julia}
DaviesBouldin(X, clusters)
```

now we optimize -- this runs on multiple threads, but it's still not super fast

```{julia}
k_trial = 3:8
score = zeros(Float64, length(k_trial))
costs = copy(score)
vscore = copy(score)
vcosts = copy(score)
Suppressor.@suppress_err begin
    Threads.@threads for j in axes(k_trial, 1)
        k = k_trial[j]
        sc = zeros(Float64, 12)
        cs = copy(sc)
        for rep in axes(sc, 1)
            cl = kmeans(X, k)
            sc[rep] = DaviesBouldin(X, cl)
            cs[rep] = cl.totalcost
        end
        score[j] = mean(sc)
        costs[j] = mean(cs)
        vscore[j] = std(sc)
        vcosts[j] = std(cs)
    end
end
```

figure with the number of clusters v. cost

```{julia}
#| label: fig-kmeans-tuning
#| fig-cap: Results of running the *k*-means algorithm ten times for each number of clusters between 3 and 8. The average Davies-Bouldin and cost are reported, as well as the standard deviation. As expected, the total cost decreases with more clusters, but this is not necessarily the sign of a better clustering.
f = Figure(; resolution=(500,500))

gl = f[1,1] = GridLayout()

ax1 = CairoMakie.Axis(gl[1,1]; xlabel="Number of clusters", ylabel="Davies-Bouldin index", xticks=3:8)
scatterlines!(ax1, k_trial, score, color=:black)
errorbars!(ax1, k_trial, score, .5vscore, .5vscore, whiskerwidth = 10)

ax2 = CairoMakie.Axis(gl[2,1]; xlabel="Number of clusters", ylabel="Total cost", xticks=3:8)
scatterlines!(ax2, k_trial, costs, color=:black)
errorbars!(ax2, k_trial, costs, .5vcosts, .5vcosts, whiskerwidth = 10)

hidexdecorations!(ax1, grid=false)

rowgap!(gl, 0.0)

current_figure()
```

now we can pick the best number of clusters and search for a solution

```{julia}
bscore, imax = findmin(score)
k = 4
clusters = kmeans(X, k)
@info DaviesBouldin(X, clusters)
```

now plot

```{julia}
#| label: fig-kmeans-optimal-landscape
#| fig-cap: Results of the landscape clustering with k=4 clusters. This number of clusters gives us a good separation between different groups of pixels, and seems to capture features of the landscape as revealed with the false-color composites.

C = permutedims(reshape(assignments(clusters), size(ndvi)))

fig = Figure(resolution=(500, 150))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_cir = Makie.Axis(fig[1,3], aspect=DataAspect())

heatmap!(ax_rgb, C; colormap=:Dark2_4)
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_cir, load(assetpath(cir_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_cir)

current_figure()
```

number of pixels per class

```{julia}
#| label: fig-kmeans-barplot-classes
#| fig-cap: Number of pixels assigned to each class in the final landscape classification. In most cases, *k*-means will create clusters with the same number of points in them. This may be an issue, or this may be a way to ensure that whatever classes are produced will be balanced in terms of their representation.
assigns = clusters.assignments
clust = unique(assigns)
counts = [count(isequal(k), assigns) for k in clust]

fig = Figure(resolution=(500,300))
ax = Makie.Axis(fig[1,1]; xlabel="Cluster", ylabel="Proportion of pixels")
scatter!(ax, sort(counts)./sum(counts), color=:slategrey)
current_figure()
```

```{julia}
#| label: fig-kmeans-clustering
#| fig-cap: Visualisation of the clustering output as a function of the NDVI and NDMI values. Note that the limits between the clusters are lines (planes), and that each cluster covers about the same volume in the space of parameters.
fig = Figure(resolution=(500,300))
ax = Makie.Axis(fig[1,1]; xlabel="Vegetation", ylabel="Moisture")
scatter!(ax, vec(ndvi), vec(ndmi), color=clusters.assignments, colormap=:Dark2_4)
tightlimits!(ax)
current_figure()
```

```{julia}
#| label: tbl-clustering-centers
#| tbl-cap: Summary of the values for the centers of the optimal clusters found in this image. The cover column gives the percentage of all pixels associated to this class. The clusters are sorted by the NDVI of their centroid.
df = DataFrame()
ctr = clusters.centers
for cluster in axes(ctr, 2)
    push!(df,
        (
            Cluster=cluster,
            Cover=round(Int, count(clusters.assignments .== cluster)/prod(size(ndvi))*100),
            NDVI=round(ctr[1,cluster]; digits=3),
            NDWI=round(ctr[2,cluster]; digits=3),
            NDMI=round(ctr[3,cluster]; digits=3),
            NBR=round(ctr[4,cluster]; digits=3)
        )
    )
end
sort!(df, :NDVI)
out = pretty_table(String, df, tf = tf_html_simple, formatters = ft_nomissing, show_subheader = false, show_header = true)
display("text/html", out)
```