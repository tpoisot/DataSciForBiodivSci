# Supp. Mat. - Clustering

This notebook uses data from the USGS Landsat 9 products. They are *not* distributed with the notebook because they are pretty large. We work from the `.dat` files that have been extracted from the raw data instead.

```{julia}
_code_path = joinpath(@__DIR__, "..", "lib")
include(joinpath(_code_path, "pkg.jl"))
include(joinpath(_code_path, "colorcube.jl"))
include(joinpath(_code_path, "daviesbouldin.jl"))
```

```{julia}
using DelimitedFiles
```

Read the different datafiles

```{julia}
_data_path = joinpath(@__DIR__, "..", "data", "kmeans", "cooked")
R = readdlm(joinpath(_data_path, "red.dat"));   # Band 4
G = readdlm(joinpath(_data_path, "green.dat")); # Band 3
B = readdlm(joinpath(_data_path, "blue.dat")); # Band 2
S1 = readdlm(joinpath(_data_path, "swir1.dat")); # Band 6
S2 = readdlm(joinpath(_data_path, "swir2.dat")); # Band 7
N = readdlm(joinpath(_data_path, "nir.dat")); # Band 5
```

RGB composite

natural color 4,3,2
cir 5,4,3
false urban 7,6,4
false veg 6,5,4

```{julia}
#| label: fig-kmeans-composites
#| fig-cap: The Landsat 9 data are combined into the "Natural Color" image, in which the red, green, and blue bands are mapped to their respective channels (left). The two other composites are the false color infrared, and the composite for vegetation analysis.
rgb_cube = colorcube(R, G, B)
veg_cube = colorcube(S1, N, R)
urb_cube = colorcube(S2, S1, R)

fig = Figure(resolution=(500, 150))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_urb = Makie.Axis(fig[1,3], aspect=DataAspect())

image!(ax_rgb, load(assetpath(rgb_cube)))
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_urb, load(assetpath(urb_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_urb)

current_figure()
```

Now we can do the NDVI, NDMI, NDWI

```{julia}
ndvi = @. (N - R) / (N + R)
ndwi = @. (G - N) / (G + N)
ndmi = @. (N - S1) / (N + S1)
```

and combine in a single matrix

```{julia}
X = zeros(Float32, (3, prod(size(ndvi))...))
X[1,:] .= vec(ndvi)
X[2,:] .= vec(ndwi)
X[3,:] .= vec(ndmi)
size(X)
```

plot

```{julia}
#| label: fig-kmeans-hexbin
#| fig-cap: The pixels acquired from Landsat 8 exist in a space with many different dimensions (one for each band). Because we are interested in a landscape classification based on water and vegetation data, we use the NDVI, NDMI, and NDWI combinations of bands. These are *derived* data, and represent the creation of new features from the raw data. Darker colors indicate more pixels in this bin.
fig = Figure(resolution=(500,500))
ax = Makie.Axis(fig[1,1]; xlabel="Vegetation", ylabel="Moisture")
hexbin!(ax, vec(ndvi), vec(ndmi), colormap=[:lightgrey, :black], bins=120)
tightlimits!(ax)
current_figure()
```

initial split

```{julia}
using Clustering
clusters = kmeans(X, 3)
```

initial classification

```{julia}
#| label: fig-kmeans-initial-landscape
#| fig-cap: After iterating the *k*-means algorithm, we obtain a classification for every pixel in the landscape. This classification is based on the values of NDVI, NDMI, and NDWI indices, and therefore groups pixels based on a specific hypothesis. This clustering was produced using $k=5$, *i.e.* we want to see what the landscape would look like when divided into three categories. 

C = permutedims(reshape(assignments(clusters), size(ndvi)))

fig = Figure(resolution=(500, 150))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_urb = Makie.Axis(fig[1,3], aspect=DataAspect())

heatmap!(ax_rgb, C; colormap=Makie.wong_colors())
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_urb, load(assetpath(urb_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_urb)

current_figure()
```

cluster score

```{julia}
DaviesBouldin(X, clusters)
```

now we optimize -- this runs on multiple threads, but it's still not super fast

```{julia}
k_trial = repeat(3:8, 10)
score = ones(Float64, length(k_trial))
costs = ones(Float64, length(k_trial))
Suppressor.@suppress_err begin
    Threads.@threads for i in 1:length(k_trial)
        k = k_trial[i]
        cl = kmeans(X, k)
        score[i] = DaviesBouldin(X, cl)
        costs[i] = cl.totalcost
    end
end
```

figure with the number of clusters v. cost

```{julia}
#| label: fig-kmeans-tuning
#| fig-cap: tuning of k
f = Figure()

gl = f[1,1] = GridLayout()

jitter = rand(length(score)).*0.2 .- 0.1

ax1 = CairoMakie.Axis(gl[1,1]; xlabel="Number of clusters", ylabel="Davies-Bouldin index", xticks=3:8)
scatter!(ax1, k_trial.+jitter, score, color=:black)

ax2 = CairoMakie.Axis(gl[2,1]; xlabel="Number of clusters", ylabel="Total cost", xticks=3:8)
scatter!(ax2, k_trial.+jitter, costs, color=:black)

hidexdecorations!(ax1, grid=false)

rowgap!(gl, 0.0)

current_figure()
```

now we can pick the best number of clusters and search for a solution

```{julia}
bscore, imax = findmin(score)
k = 4
clusters = kmeans(X, k)
@info DaviesBouldin(X, clusters)
```

now plot

```{julia}
#| label: fig-kmeans-optimal-landscape
#| fig-cap: blah

C = permutedims(reshape(assignments(clusters), size(ndvi)))

fig = Figure(resolution=(500, 170))
ax_rgb = Makie.Axis(fig[1,1], aspect=DataAspect())
ax_veg = Makie.Axis(fig[1,2], aspect=DataAspect())
ax_urb = Makie.Axis(fig[1,3], aspect=DataAspect())

heatmap!(ax_rgb, C; colormap=Makie.wong_colors())
image!(ax_veg, load(assetpath(veg_cube)))
image!(ax_urb, load(assetpath(urb_cube)))

hidedecorations!(ax_rgb)
hidedecorations!(ax_veg)
hidedecorations!(ax_urb)

current_figure()
```

number of pixels per class

```{julia}
#| label: fig-kmeans-barplot-classes
#| fig-cap: Number of pixels assigned to each class in the final landscape classification. In most cases, *k*-means will create clusters with the same number of points in them. This may be an issue, or this may be a way to ensure that whatever classes are produced will be balanced in terms of their representation.
assigns = clusters.assignments
clust = unique(assigns)
counts = [count(isequal(k), assigns) for k in clust]

fig = Figure(resolution=(500,300))
ax = Makie.Axis(fig[1,1]; xlabel="Cluster", ylabel="Proportion of pixels")
scatter!(ax, sort(counts)./sum(counts), color=:slategrey)
current_figure()
```

```{julia}
#| label: fig-kmeans-clustering
#| fig-cap: Visualisation of the clustering output using ...
scatter(vec(ndvi), vec(ndmi), color=clusters.assignments, colormap=Makie.wong_colors())
```