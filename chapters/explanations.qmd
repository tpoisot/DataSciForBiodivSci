---
engine: julia
---

# Explaining predictions {#sec-explanations}

In this chapter, we will

```{julia}
#| echo: false
#| output: false
_code_path = joinpath(dirname(Base.active_project()), "code")
include(joinpath(_code_path, "pkg.jl"))
include(joinpath(_code_path, "minisdm/pipelines.jl"))
include(joinpath(_code_path, "minisdm/shapley.jl"))
```

navigate the accuracy-explainability for public policy @bell2022

what is explainable differs between stakeholders @amarasinghe2023

biodiversity need sustained model uptake @weiskopf2022

@strumbelj2013 monte carlo approximation of shapley values

@wadoux2023 mapping of shapley values

@mesgaran2014 mapping of most important covariates

@lundberg2017 SHAP

transfo in model = we can still apply these techniques instead of asking "what does PC1 = 0.4 mean"

## Application

```{julia}
JLD2.jldopen(joinpath(_models_path, "sdm-training-data.jld2"), "r") do file
    global X = file["X"]
    global y = file["y"]
    global folds = file["folds"]
    global coordinates = file["coordinates"]
end;

# Load the model
modelpath = joinpath(_models_path, "sdm-baseline.json")
model = loadsdm(modelpath)
model.v = [1,2,3,4,12]
train!(model)
```

```{julia}
predictor = (p) -> predict(model, p; threshold=false)

S = zeros(Float64, (length(model.v), length(y)))
for (vidx, vpos) in enumerate(model.v)
    for instance in axes(S, 2)
        S[vidx,instance] = shap_one_point(predictor, X, X, instance, vpos, 100)
    end
end
P = X[model.v,:]
```

```{julia}
varimp = vec(mean(abs.(S); dims=2))
varimp ./= sum(varimp)
varord = sortperm(varimp; rev=true)
for v in varord
    vname = model.v[v]
    vctr = round(Int, varimp[v]*100)
    println("$(vname) - $(vctr)%")
end
```

```{julia}
shaps = S[:,2]

f = Figure()

ax = Axis(f[1,1], yticks = (reverse(collect(1:length(model.v))), ["BIO$(v)" for v in model.v]))
xlims!(ax, low=-0.5, high=0.5)

vlines!([0.0], color=:black, linestyle=:dash)

starts = cumsum(shaps) .- shaps
elev = reverse(collect(axes(shaps, 1)))
ydir = zeros(length(shaps))

arrows!(ax, starts, elev, shaps, ydir, align=:tailhead)
scatter!(ax, [P[1]-mean(P)], [1], color=:transparent, strokecolor=:red, strokewidth=3, markersize=25)

current_figure()
```

```{julia}
f = Figure()
gl = f[1,1] = GridLayout()
ax1 = Axis(gl[1,1]; ylabel="BIO $(model.v[varord[1]])", xaxisposition=:top)
density!(ax1, S[varord[1],:])
ax2 = Axis(gl[1,2]; ylabel="BIO $(model.v[varord[2]])", xaxisposition=:top, yaxisposition=:right)
density!(ax2, S[varord[2],:])
ax3 = Axis(gl[2,1]; ylabel="BIO $(model.v[varord[3]])", xaxisposition=:top, yaxisposition=:right)
density!(ax3, S[varord[3],:])

xmin, xmax = extrema(S)
for ax in [ax1, ax2, ax3]
    xlims!(ax, low=xmin, high=xmax)
    ylims!(ax, low=0.0)
    hideydecorations!(ax, label=false)
end

rowgap!(gl, 0.0)
colgap!(gl, 0.0)

current_figure()
```

```{julia}
f = Figure()
args = (color=predict(model), markersize=5, colorrange=(0., 1.))

ax1 = Axis(f[1,1]; xlabel="BIO $(model.v[varord[1]])")
scatter!(ax1, P[varord[1],:], S[varord[1],:]; args...)
ax2 = Axis(f[1,2]; xlabel="BIO $(model.v[varord[2]])")
scatter!(ax2, P[varord[2],:], S[varord[2],:]; args...)
ax3 = Axis(f[2,1]; xlabel="BIO $(model.v[varord[3]])")
scatter!(ax3, P[varord[3],:], S[varord[3],:]; args...)

xmin, xmax = extrema(S)
for ax in [ax1, ax2, ax3]
    hlines!(ax, [0.0], color=:black, linestyle=:dash)
end

current_figure()
```

```{julia}
_layer_path = joinpath(dirname(Base.active_project()), "data", "general", "layers.tiff")
bio = [SpeciesDistributionToolkit._read_geotiff(_layer_path, SimpleSDMResponse; bandnumber=i) for i in 1:19]
```

```{julia}
V = [convert(Float32, similar(bio[1])) for i in axes(model.v, 1)]

B = Float64.(permutedims(hcat(values.(bio)...)))
for i in axes(model.v, 1)
    A = shap_all_points(predictor, B, X, model.v[i], 10)
    V[i].grid[findall(!isnothing, V[i].grid)] .= A
end
```

```{julia}
heatmap(V[varord[1]], colormap=nightfall, colorrange=(-0.2,0.2))
```

```{julia}
mostimp = mosaic(x -> argmax(abs.(x)), V)

cmap = bright[2:length(model.v)+1]

f = Figure()
ax = Axis(f[1,1])

heatmap!(ax, mostimp, colormap=cmap)

cleg = [PolyElement(color = c, strokecolor = :transparent) for c in cmap]
clab = ["BIO$(s)" for s in model.v]
Legend(f[1,1], cleg, clab; tellheight=false, tellwidth=false, halign=:left, valign=:top, margin=(10, 10, 10, 10))

current_figure()
```