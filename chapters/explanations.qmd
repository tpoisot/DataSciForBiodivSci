# Explaining predictions {#sec-explanations}

In this chapter, we will

navigate the accuracy-explainability for public policy @bell2022

what is explainable differs between stakeholders @amarasinghe2023

biodiversity need sustained model uptake @weiskopf2022

@strumbelj2013 monte carlo approximation of shapley values

@wadoux2023 mapping of shapley values

@mesgaran2014 mapping of most important covariates

@lundberg2017 SHAP

TODO 10.1186/s12911-021-01569-9

transfo in model = we can still apply these techniques instead of asking "what does PC1 = 0.4 mean"

```{julia}
#| echo: false
#| output: false
_code_path = joinpath(dirname(Base.active_project()), "lib")
include(joinpath(_code_path, "pkg.jl"))
include(joinpath(_code_path, "confusion.jl"))
include(joinpath(_code_path, "nbc.jl"))
include(joinpath(_code_path, "palettes.jl"))
include(joinpath(_code_path, "shapley.jl"))
```

model

```{julia}
#| echo: false
#| output: false
_ptm_path = joinpath(dirname(Base.active_project()), "checkpoints")
modelpath = joinpath(_ptm_path, "sdm-step-2.jld")
ptm = JLD.load(modelpath)
y = ptm["labels"]
X = ptm["features"]
v = ptm["variables"]
tf = ptm["transformation"]
τ = ptm["threshold"]
model = naivebayes(y, X; transformation=tf)
```

```{julia}
#| echo: false
#| output: false
_layer_path = joinpath(dirname(Base.active_project()), "data", "general", "layers.tiff")
bio = [SpeciesDistributionToolkit._read_geotiff(_layer_path, SimpleSDMResponse; bandnumber=i) for i in v]

pr = convert(Float64, similar(first(bio)))

Threads.@threads for k in keys(pr)
    x = [bio[i][k] for i in axes(v, 1)]
    pr[k] = model(x)
end
```

```{julia}
#| label: fig-shapley-example
#| fig-cap: Example of the contribution of the model variables to the prediction. The dashed line indicates the average prediction across all instances, and each arrow shows how the value of the feature for this instance moves the prediction, in an additive way. The length of each arrow is the Shapley value for this feature in this instance. The final prediction (in this case, how much higher/lower than the average) is given in a red cirle.
idx = 500
S = [shapley(model, X, idx, j; M=20_000) for j in eachindex(v)]
P = [model(X[i,:]) for i in axes(X, 1)]
p = P[idx]

f = Figure()

ax = Axis(f[1,1], yticks = (collect(length(v):-1:1), ["BIO$(i)" for i in v]))
xlims!(ax, low=-0.6, high=0.6)

vlines!([0.0], color=:black, linestyle=:dash)

starts = cumsum(S) .- S
elev = reverse(collect(axes(S, 1)))
ydir = zeros(length(S))

arrows!(ax, starts, elev, S, ydir, align=:tailhead)
scatter!(ax, starts, elev, color=:black, markersize=8)
scatter!(ax, [p-mean(P)], [1], color=:transparent, strokecolor=:red, strokewidth=3, markersize=25)

current_figure()
```


```{julia}
S = similar(X)
Threads.@threads for i in axes(X, 1)
    for j in axes(X, 2)
        S[i,j] = shapley(model, X, i, j; M=5000)
    end
end
P = [model(X[i,:]) for i in axes(X, 1)]
```

variable importance

```{julia}
varimp = vec(sum(abs.(S); dims=1))
varimp ./= sum(varimp)
vord = sortperm(varimp; rev=true)
```

table with variable rank in selection

```{julia}
hdr = "| Variable | Selection rank | Importance rank | Rel. importance |"
sep = "|-----|-----|-----|------|"
tbl = [hdr, sep]
for i in eachindex(v)
    row = "| BIO$(v[i]) | $i | $(vord[i]) | $(round(Int, varimp[i]*100))% |"
    push!(tbl, row)
end
push!(tbl, "\n: List of the $(length(v)) variables selected in @sec-predictors, ranked by their order of inclusion. Their rank in terms of importance, as well as relative importance, are also provided. {#tbl-explanations-importance}")
try
    display("text/markdown", join(tbl, "\n"))
catch e
end
```

variable importance plot

```{julia}
fig = Figure()
ax = Axis(fig[1,1]; xlabel="Relative variable importance")
barplot!(ax, varimp[reverse(vord)], direction=:x, bar_labels = "BIO".*string.(v[reverse(vord)]), flip_labels_at = 0.05, color=light[1])
xlims!(ax, (0.0, maximum(varimp)*1.05))
hideydecorations!(ax)
hidexdecorations!(ax, grid=true, ticks=false, label=false, ticklabels=false)
hidespines!(ax)
current_figure()
```

plots

```{julia}
f = Figure(; resolution=(700, 400))
gl = f[1,1] = GridLayout()

xmin, xmax = maximum(abs.(extrema(S))) .* (-1, 1)
hbins = round(xmin, digits=2):0.005:round(xmax, digits=2)

ax1 = Axis(gl[1,1]; ylabel="BIO $(v[vord[1]])", xaxisposition=:top)
hist!(ax1, S[:,vord[1]], color=bright[1], bins=hbins)
ax2 = Axis(gl[2,1]; ylabel="BIO $(v[vord[2]])", yaxisposition=:right)
hist!(ax2, S[:,vord[2]], color=bright[1], bins=hbins)
ax3 = Axis(gl[3,1]; ylabel="BIO $(v[vord[3]])")
hist!(ax3, S[:,vord[3]], color=bright[1], bins=hbins)
ax4 = Axis(gl[4,1]; ylabel="BIO $(v[vord[4]])", yaxisposition=:right)
hist!(ax4, S[:,vord[4]], color=bright[1], bins=hbins)

hidexdecorations!(ax2, grid=false)
hidexdecorations!(ax3, grid=false)

for ax in [ax1, ax2, ax3, ax4]
    xlims!(ax, low=xmin, high=xmax)
    ylims!(ax, low=0.0)
    vlines!(ax, [0.0], color=:black, linestyle=:dash)
    hideydecorations!(ax, label=false)
end

rowgap!(gl, 0.0)
colgap!(gl, 0.0)

current_figure()
```

partial responses

```{julia}
f = Figure()
args = (color=y, markersize=3, colorrange=(0., 1.), colormap=vibrant[1:2])

ax1 = Axis(f[1,1]; xlabel="BIO $(v[vord[1]])")
scatter!(ax1, X[:,vord[1]], S[:,vord[1]]; args...)
ylims!(ax1, maximum(abs.(extrema(S[:,vord[1]]))).*(-1.1,1.1))
ax2 = Axis(f[2,1]; xlabel="BIO $(v[vord[2]])")
scatter!(ax2, X[:,vord[2]], S[:,vord[2]]; args...)
ylims!(ax2, maximum(abs.(extrema(S[:,vord[2]]))).*(-1.1,1.1))
ax3 = Axis(f[3,1]; xlabel="BIO $(v[vord[3]])")
scatter!(ax3, X[:,vord[3]], S[:,vord[3]]; args...)
ylims!(ax3, maximum(abs.(extrema(S[:,vord[3]]))).*(-1.1,1.1))

axm = Axis(f[1:3,2]; aspect=DataAspect())
heatmap!(axm, pr .>= τ, colormap=vibrant[1:2])
hidedecorations!(axm)
hidespines!(axm)

xmin, xmax = extrema(S)
for ax in [ax1, ax2, ax3]
    hlines!(ax, [0.0], color=:black, linestyle=:dash)
end

current_figure()
```

map

```{julia}
V = [convert(Float32, similar(bio[1])) for i in axes(v, 1)]

Threads.@threads for k in keys(V[1])
    x = [b[k] for b in bio]
    for i in axes(v, 1)
        V[i][k] = shapley(model, X, x, i; M=1000)
    end
end
```

```{julia}
mostimp = mosaic(x -> argmax(abs.(x)), V)
mostimp = (x -> x >= 4.0 ? 4.0 : x).(mostimp)
cmap = muted[[2,3,4,1]]

f = Figure()
ax = Axis(f[1,1]; aspect=DataAspect())

heatmap!(ax, mostimp, colormap=cmap)

cleg = [PolyElement(color = c, strokecolor = :transparent) for c in cmap]
clab = ["BIO".*string.(v[vord[1:3]])..., "Other"]
Legend(f[1,1], cleg, clab; tellheight=false, tellwidth=false, halign=:left, valign=:top, margin=(10, 10, 10, 10))

current_figure()
```