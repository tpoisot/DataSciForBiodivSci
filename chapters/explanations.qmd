---
engine: julia
---

# Explaining predictions {#sec-explanations}

In this chapter, we will

```{julia}
#| echo: false
#| output: false
_code_path = joinpath(dirname(Base.active_project()), "code")
include(joinpath(_code_path, "pkg.jl"))
include(joinpath(_code_path, "minisdm/pipelines.jl"))
include(joinpath(_code_path, "minisdm/shapley.jl"))
```

navigate the accuracy-explainability for public policy @bell2022

what is explainable differs between stakeholders @amarasinghe2023

biodiversity need sustained model uptake @weiskopf2022

@strumbelj2013 monte carlo approximation of shapley values

@wadoux2023 mapping of shapley values

@mesgaran2014 mapping of most important covariates

@lundberg2017 SHAP

transfo in model = we can still apply these techniques instead of asking "what does PC1 = 0.4 mean"

## Application

```{julia}
JLD2.jldopen(joinpath(_models_path, "sdm-training-data.jld2"), "r") do file
    global X = file["X"]
    global y = file["y"]
    global folds = file["folds"]
    global coordinates = file["coordinates"]
end;

# Load the model
modelpath = joinpath(_models_path, "sdm-threshold.json")
model = loadsdm(modelpath; threshold=false)
```

```{julia}
S = zeros(Float64, (length(model.v), length(y)))
for (vidx, vpos) in enumerate(model.v)
    S[vidx,:] = explain(model, vpos; threshold=false, samples=200)
end
P = X[model.v,:]
```

TODO redraw the stemplot from the variable selection chapter to compare prediction v. explanation

```{julia}
#| echo: false
#| output: asis
#| label: tbl-explanations-importance
#| tbl-cap: blah blah blah
varimp = vec(mean(abs.(S); dims=2))
varimp ./= sum(varimp)
varord = sortperm(varimp; rev=true)

content = Vector{Any}[]
for v in varord
    vname = model.v[v]
    vctr = round(Int, varimp[v]*100)
    push!(content, [
        vname, 100varimp[v], minimum(S[v,:]), median(S[v,:]), maximum(S[v,:])
    ])
end

D = permutedims(hcat(content...))

pretty_table(
    D;
    backend = Val(:markdown),
    header = ["Variable", "Importance", "Min.", "Med.", "Max."],
    alignment = [:c, :l, :l, :l, :l, :l],
    formatters = (ft_printf("%1i", 1), ft_printf("%5.2f%%", 2), ft_printf("%5.2f", [3,4,5])),
)
```

```{julia}
#| echo: false
#| label: fig-explanation-waterfall
#| fig-scap: Waterfall diagram for a single prediction.
#| fig-cap: Effect of each variable (sorted by importance as in @tbl-explanations-importance) on the change of the score for a single prediction. Recall that this is expressed as the change from the *average* prediction made by the model.
shaps = S[:,2][varord]

f = Figure(; size=(4, 6).*(600/6))

ax = Axis(f[1,1], yticks = (reverse(collect(1:length(model.v))), ["BIO$(v)" for v in model.v[varord]]))
xlims!(ax, low=-0.6, high=0.6)

vlines!([0.0], color=:black, linestyle=:dash)

starts = cumsum(shaps) .- shaps
elev = reverse(collect(axes(shaps, 1)))
ydir = zeros(length(shaps))

arrows!(ax, starts, elev, shaps, ydir, align=:tailhead)
scatter!(ax, [P[1]-mean(P)], [1], color=:transparent, strokecolor=:red, strokewidth=3, markersize=25)

current_figure()
```

```{julia}
#| echo: false
#| label: fig-explanation-effects
#| fig-scap: Distribution of the effects on the average prediction for the three most important variables.
#| fig-cap: Effect of each variable (sorted by importance as in @tbl-explanations-importance) on the change of the score for a single prediction. Recall that this is expressed as the change from the *average* prediction made by the model.
f = Figure(; size=(7, 6).*(600/6))
gl = f[1,1] = GridLayout()

xmin, xmax = extrema(S)

ax1 = Axis(gl[1,1]; ylabel="BIO $(model.v[varord[1]])", xaxisposition=:top)
hist!(ax1, S[varord[1],:], color=:grey, bins=LinRange(xmin, xmax, 50))
ax2 = Axis(gl[2,1]; ylabel="BIO $(model.v[varord[2]])", xaxisposition=:top, yaxisposition=:right)
hist!(ax2, S[varord[2],:], color=:grey, bins=LinRange(xmin, xmax, 50))
ax3 = Axis(gl[3,1]; ylabel="BIO $(model.v[varord[3]])", xaxisposition=:bottom, yaxisposition=:left)
hist!(ax3, S[varord[3],:], color=:grey, bins=LinRange(xmin, xmax, 50))

hidexdecorations!(ax2, label=false, grid=false)

for ax in [ax1, ax2, ax3]
    xlims!(ax, low=xmin, high=xmax)
    ylims!(ax, low=0.0)
    vlines!(ax, [0.0], color=:black, linestyle=:dash)
    hideydecorations!(ax, label=false)
end

rowgap!(gl, 0.0)
colgap!(gl, 0.0)

current_figure()
```

```{julia}
f = Figure()
args = (color=predict(model), markersize=5, colorrange=(0., 1.))

ax1 = Axis(f[1,1]; xlabel="BIO $(model.v[varord[1]])")
scatter!(ax1, P[varord[1],:], S[varord[1],:]; args...)
ax2 = Axis(f[1,2]; xlabel="BIO $(model.v[varord[2]])")
scatter!(ax2, P[varord[2],:], S[varord[2],:]; args...)
ax3 = Axis(f[2,1]; xlabel="BIO $(model.v[varord[3]])")
scatter!(ax3, P[varord[3],:], S[varord[3],:]; args...)

xmin, xmax = extrema(S)
for ax in [ax1, ax2, ax3]
    hlines!(ax, [0.0], color=:black, linestyle=:dash)
end

current_figure()
```

```{julia}
_layer_path = joinpath(dirname(Base.active_project()), "data", "general", "layers.tiff")
bio = [SpeciesDistributionToolkit._read_geotiff(_layer_path, SimpleSDMResponse; bandnumber=i) for i in 1:19]
```

```{julia}
V = [convert(Float32, similar(bio[1])) for i in axes(model.v, 1)]

B = Float64.(permutedims(hcat(values.(bio)...)))
for i in axes(model.v, 1)
    A = explain(model, model.v[i]; instances=B, threshold=false)
    V[i].grid[findall(!isnothing, V[i].grid)] .= A
end
```

```{julia}
heatmap(V[varord[1]], colormap=bkcol.div, colorrange=(-0.5,0.5))
```

```{julia}
#| echo: false
#| label: fig-explanations-mosaic
#| fig-scap: Mosaic of the most important variable for each pixel
#| fig-cap: TODO
mostimp = mosaic(x -> argmax(abs.(x)), V)

nvars = 3
cmap = [bkcol.cat[1:nvars]..., bkcol.nodata]
clab = push!("BIO" .* string.(model.v[varord][1:nvars]), "other")

f = Figure(; size=(7, 5).*(600/6))
ax = Axis(f[1,1], aspect=DataAspect())

mvar = similar(mostimp)
mvar.grid[findall(!isnothing, mvar.grid)] .= nvars+1
for i in 1:nvars
    mvar.grid[findall(isequal(varord[i]), mostimp.grid)] .= i
end

heatmap!(ax, mvar, colormap=cmap)
hidespines!(ax)
hidexdecorations!(ax)
hideydecorations!(ax)

cleg = [PolyElement(color = c, strokecolor = :transparent) for c in cmap]
Legend(f[1,1], cleg, clab; tellheight=false, tellwidth=false, halign=:left, valign=:top, margin=(10, 10, 10, 10), nbanks=2)

current_figure()
```


```{julia}
#| output: false
#| echo: false
modelpath = joinpath(_models_path, "sdm-importance.json")
model.v = model.v[varord]
writesdm(modelpath, model)
```